#!/usr/bin/env python3

import RPi.GPIO as GPIO
import time

# Pin assignments
motor_pin = 7     # Physical pin 7, GPIO4 (buzzer/motor)
trig_pin = 11     # Physical pin 11, GPIO17
echo_pin = 12     # Physical pin 12, GPIO18

# Setup function
def setup():
    GPIO.setmode(GPIO.BOARD)
    GPIO.setup(motor_pin, GPIO.OUT)
    GPIO.setup(trig_pin, GPIO.OUT)
    GPIO.setup(echo_pin, GPIO.IN)

    global motor_pwm
    motor_pwm = GPIO.PWM(motor_pin, 1000)  # 1 kHz PWM
    motor_pwm.start(0)  # Start off

# Distance measurement function with timeout
def distance():
    GPIO.output(trig_pin, GPIO.LOW)
    time.sleep(0.000001)
    GPIO.output(trig_pin, GPIO.HIGH)
    time.sleep(0.00001)
    GPIO.output(trig_pin, GPIO.LOW)

    # Wait for echo to go HIGH
    start_time = time.time()
    while GPIO.input(echo_pin) == 0:
        if time.time() - start_time > 0.02:  # 20 ms timeout
            return None
    time1 = time.time()

    # Wait for echo to go LOW
    start_time = time.time()
    while GPIO.input(echo_pin) == 1:
        if time.time() - start_time > 0.02:  # 20 ms timeout
            return None
    time2 = time.time()

    duration = time2 - time1
    distance_cm = (duration * 340 / 2) * 100
    return distance_cm

# Buzzer/motor control
def motor_on(intensity, sleep_time):
    motor_pwm.ChangeDutyCycle(intensity)
    time.sleep(sleep_time)
    motor_pwm.ChangeDutyCycle(0)
    time.sleep(sleep_time)

def motor_off():
    motor_pwm.ChangeDutyCycle(0)

# Main loop
def loop():
    while True:
        dis = distance()
        if dis is None:
            continue  # Skip invalid reading

        if dis <= 275:
            motor_on(50, 0.2)   # Fast buzzing for close objects
        elif dis <= 600:
            motor_on(50, 0.5)   # Slower buzzing for mid-range objects
        else:
            motor_off()
            time.sleep(0.1)     # Small pause to reduce CPU usage

# Run script
if __name__ == "__main__":
    setup()
    try:
        loop()
    except KeyboardInterrupt:
        motor_off()
        GPIO.cleanup()
